function bpmDisp
%function bpmDisp
%Calculated correlation coefficient between all bpms and dispersion BPM and
%writes information to waveform PV
%disp('export EPICS_CA_MAX_ARRAY_BYTES=800000');
fprintf('\n%s bpmDisp Started\n',datestr(now))
warning('off', 'MATLAB:polyfit:RepeatedPointsOrRescale');
%For FFT
df = 120/2800;                  %Resolution frequency 120 Hz and 2800 BSA pts.
f = 0:df:120 - df;         %Analysis frequencies
fDsp = f(1:1400)';
lcaPutSmart('CUD:MCC0:BPMS_FFT:WAVEFORM1', fDsp);
fftWfPvs =  strrep('CUD:MCC0:BPMS_FFT:WAVEFORM1','1', {'2','3','4','5','6','7','8','9'})';


%For Corelation coefficient.

DATA = getBSA_names(); %Init data for BSA correlation cofficient.
%Reduce size of DATA.root_name to save memory
removeList = {'VPIO', 'VGCC','UBLF', 'VGPR', 'PMT', 'PICS', 'LLRF', 'BLM', 'TORO', 'BLD', 'WIRE', 'PCAV', 'LASR', 'IOC', 'TCAV', 'PATT' };
removeIndx = [];
for s = removeList
    removeIndx = [removeIndx; strmatch(s, DATA.root_name)];
end

DATA.root_name(removeIndx) = [];
DATA.nameTail(removeIndx) = [];
DATA.nameTail1(removeIndx) = [];
DATA.z_positions(removeIndx) = [];

historyPvs = aidalist('%ENERGYJITTER');
kx = strmatch(':X',DATA.nameTail);
ky = strmatch(':Y',DATA.nameTail);
kt = strmatch('IT',DATA.nameTail);
kp = strmatch('PHAS_FAST',DATA.nameTail1);
kp2 = [strmatch(':A',DATA.nameTail); strmatch(':P', DATA.nameTail); strmatch('_A',DATA.nameTail); strmatch('_P', DATA.nameTail)];
ki = strmatch('AX', DATA.nameTail);
kv = strmatch('LT', DATA.nameTail);
rmsE = zeros(1,175); %Length ouf output waveform PV    

bpmsToShow = {'BPMS:LTU0:110:X'; 'BPMS:LTU0:120:X'; 'BPMS:LTU0:130:X'; 'BPMS:LTU1:250:X'; ...
                           'BPMS:LTU0:110:Y'; 'BPMS:LTU0:120:Y'; 'BPMS:LTU0:130:Y'; 'BPMS:LTU1:250:Y'         }; %in FFT

n=model_nameRegion('BPMS','CU_HXR');     
%Remove units not in running mode.
onlinePvs = strcat(n,':ACCESS');
onlineVals = lcaGetSmart(onlinePvs);
useIndx = strmatch('Running',onlineVals);
n = n(useIndx);

% for dispersion max and std per region
regionList = {'L2','BC2_L3END' 'BSY' 'LTU0' 'LTU1' 'UND1'};
perRegionPVs = strrep('SIOC:SYS0:ML01:AO0XX', 'XX', {'73' '74' '75' '76' '77' '78' '87' '88' '89' '90' '91' '92' });
jj = 1;
for ii = 1:length(regionList)
    nn = model_nameRegion('BPMS',regionList{ii}); 
    if ii == 5, [a b] = intersect(nn, {'BPMS:LTUH:250', 'BPMS:LTUH:450'}); nn(b) = []; end%removes LTU dispersion BPMs
    [dummy regionIndx{ii}] = intersect(n,nn);
    lcaPutSmart(strcat(perRegionPVs(jj:jj+1),'.DESC'), strrep(sprintf('%s ? Max disp from Jit.',regionList{ii}),'?',{'X','Y'}));
    jj = jj+2;
end
lcaPutSmart(strrep(perRegionPVs, 'AO', 'SO0'), 'bpmDisp.m');

[oo ooo bpmIndx] = intersect({'BPMS:LI21:233:X', 'BPMS:LI24:801:X', 'BPMS:LTU1:250:X', 'BPMS:LTU1:450:X'},strcat(n,':X'));
%ietaBPM = strmatch(bpmDl1PV(1:15), DATA.root_name);
%[oo ooo ietaBPM] = intersect({'BPMS:LI21:233:X', 'BPMS:LI24:801:X', 'BPMS:LTU1:250:X'}, DATA.root_name); %#ok<ASGLU>
[oo ooo bpmYcouplingIndx] =  intersect({'BPMS:LTU1:290:Y', 'BPMS:LTU1:390:Y', 'BPMS:LTU1:490:Y', 'BPMS:LTU1:590:Y'}, strcat(n,':Y')); 
[oo ooo bpmXcouplingIndx] =  intersect({'BPMS:BSYH:640:X'}, strcat(n,':X'));  %Was BPMS:BSY:83:X before BSY for LCLSII 
couplingPV = strcat('SIOC:SYS0:ML01:AO', {'230', '231', '232', '233'});
z=model_rMatGet(n,[],[],'Z');
nBpms = length(n);
%eDefOn(eDefN); tic
debugOn = 0
[rMat, zPos, lEff, twiss, energy] = model_rMatGet({'BPMS:LI21:233', 'BPMS:LI24:801', 'BPMS:LTU1:250'},[],['TYPE=' 'DESIGN']); %#ok<ASGLU>
    etaValAtBPM = 1000* twiss(5,:);
    
lcaSetMonitor('SIOC:SYS0:ML01:AO086'); initBR = 1;
eDefN =[];  done = 0;  
while(1) 
    val  = lcaGetSmart({'SIOC:SYS0:ML01:AO069'; 'SIOC:SYS0:ML01:AO070'; 'EVNT:SYS0:1:LCLSBEAMRATE'; ...
        'SIOC:SYS0:ML00:AO289'; 'SIOC:SYS0:ML00:AO500'});
    nMeas = val(1);
    newBR = lcaNewMonitorValue('SIOC:SYS0:ML01:AO086');
    if newBR || initBR
        initBR = 0;
        useBR = lcaGetSmart('SIOC:SYS0:ML01:AO086');
        if useBR
            nAll=[strcat(n,':X');strcat(n,':Y');strcat(n,':TMIT')];
            %bpmDl1Indx = strmatch(bpmDl1PV , nAll);
            if any(eDefN), eDefRelease(eDefN); end
        else
            if isempty(eDefN)
                eDefN = eDefReserve('BPM Dispersion/RMS');
                eDefS = num2str(eDefN);
                lcaPutSmart(['EDEF:SYS0:', eDefS, ':AVGCNT'], 1);
                %lcaPutSmart(['EDEF:SYS0:' , eDefS, ':MEASCNT'], nMeas);
                bpmDl1PV = ['BPMS:LTU1:250:XHST', eDefS];
                %bpmDl3PV = ['BPMS:LTU1:450:XHST', eDefS];
                nAll=[strcat(n,[':XHST', eDefS]);strcat(n,[':YHST', eDefS]);strcat(n,[':TMITHST', eDefS])];
                %bpmDl1Indx = strmatch(bpmDl1PV , nAll);
            end
        end
    end
    
    tic
    try
    isRunning = str2num(datestr(now,'MM')) + 60 * str2num(datestr(now,'HH'));
    lcaPutSmart('SIOC:SYS0:ML01:AO071', isRunning);
    
    %val  = lcaGetSmart({'SIOC:SYS0:ML01:AO069'; 'SIOC:SYS0:ML01:AO070'; 'EVNT:SYS0:1:LCLSBEAMRATE'; ...
    %    'SIOC:SYS0:ML00:AO289'; 'SIOC:SYS0:ML00:AO500'});
    
    %nMeas = val(1);
    bpmDl2_eta = etaValAtBPM(3);
    beamRate = val(3);
    energyVernier =val(4);
    beamEnergy = val(5);
    if beamRate < 10 && ~debugOn, pause(5), continue, end   
    beamOnStat = lcaGetSmart({'BPMS:LTU1:250:STA_ALHFP'; 'BPMS:LTU1:450:STA_ALHFP'});
    beamOnBoth = ( 3 ==  sum(strmatch('On',beamOnStat)) );
    beamOnFirst = ( 1 ==  sum(strmatch('On',beamOnStat{1})) );
    beamOnBC1 = ( 1 == sum(strmatch('On', lcaGetSmart('BPMS:LI21:233:STA_ALHFP')) ));
    beamOnBC2 = ( 1 == sum(strmatch('On', lcaGetSmart('BPMS:LI24:801:STA_ALHFP')) ));
%     
    
    
    
    if ~beamOnFirst && ~debugOn, pause(5), continue, end
    
    %Pause for data if Last Active Time longer than 20 seconds
    if ~useBR
        lcaPutSmart(['EDEF:SYS0:' , eDefS, ':MEASCNT'], nMeas);
        edefActiveT = lcaGet(['EDEF:SYS0:' eDefS ':CTRLONTOD']);
        edefActiveT = datenum(edefActiveT{1});
        if (now - edefActiveT) > 60/(24*3600)
            eDefOn(eDefN);
            %fprintf('\n eDef 25 sec. %s\n', datestr(now))
        end
    end
    
    if ~useBR, done =eDefDone(eDefN) ; end
    while ~done && ~useBR, done = eDefDone(eDefN); 
        pause(0.1), 
        isRunning = str2num(datestr(now,'MM')) + 60 * str2num(datestr(now,'HH'));
        lcaPutSmart('SIOC:SYS0:ML01:AO071', isRunning);
    end
    if ~useBR
        [data,ts1]=lcaGetSmart(nAll);
        data =  reshape(data,[],3,2800);
        %[the_matrix,ts]=lcaGetSmart(strcat(DATA.root_name,['HST', eDefS]));
        nPtsAvail = size(data,3);
        
    elseif debugOn
        [the_matrix DATA.root_name kx ky kt kp kp2 ki kv] = getMat_BSAGUIfile;
        %ietaBPM = strmatch('BPMS:LI21:233:X', DATA.root_name);
        
    else
        
        for k = 1:6
            data = [];
            try
                [data,ts1]=lcaGetSyncHST(nAll, nMeas);
                %[the_matrix,ts] = lcaGetSyncHST(DATA.root_name, nMeas);
                if length(ts1) >= nMeas*0.8
                    break
                end
                pause(nMeas/beamRate);
            catch
                fprintf('Failed lcaGetSyncHST(nAll), pausing...');
                pause(30)
            end
            
        end
        % Figure could not  get the data, bail out of loop and try again.
        if isempty(data), fprintf('%s BPM data is empty. Will try again',datestr(now)); continue; end
        if k == 6, fprintf('%s Poor data, got %i sync pulses from %i requested',datestr(now), length(ts1), nMeas);end
        derp = 1+mod(length(ts1),4);
        data = data(:,derp:end);
        ts1 = ts1(derp:end);
        nPtsAvail = size(data,2);
        data =  reshape(data,[],3,nPtsAvail);        
    end
    
    %Reduce size of DATA.root_name to save memory
    
   
    if ~useBR, eDefOn(eDefN), end

     jj=1;   
        isRunning = str2num(datestr(now,'MM')) + 60 * str2num(datestr(now,'HH'));
        lcaPutSmart('SIOC:SYS0:ML01:AO071', isRunning);
        %fprintf('\n CUD %s\n', datestr(now))
        bufRange = jj:min(jj+nMeas-1,nPtsAvail);
        try
            x = squeeze(data(:,1,:) );  x = x(:,bufRange);
            y = squeeze(data(:,2,:) );  y = y(:,bufRange);
            t = squeeze(data(:,3,:) );   t = t(:,bufRange);
        catch
            fprintf('%s Failed to generate x,y,t values near line 77',datestr(now))
            keyboard
        end
        bpmBC1x = x(bpmIndx(1),:);
        bpmBC2x = x(bpmIndx(2),:);
        bpmDl1x = x(bpmIndx(3), :);
        bpmDl3x = x(bpmIndx(4), :);


        for ii = 1:nBpms
            pFitX_DL1(ii,:) = polyfit(bpmDl1x,x(ii,:),1);
            pFitY_DL1(ii,:) = polyfit(bpmDl1x,y(ii,:),1);
            pFitX_BC1(ii,:) = polyfit(bpmBC1x,x(ii,:),1);
            pFitY_BC1(ii,:) = polyfit(bpmBC1x,y(ii,:),1);
            pFitX_BC2(ii,:) = polyfit(bpmBC2x,x(ii,:),1);
            pFitY_BC2(ii,:) = polyfit(bpmBC2x,y(ii,:),1);
        end
        xMean = 1000 * mean(x(:,12),2);
        yMean = 1000 * mean(y(:,12),2);
       % xStd = std(x,0,2);
       % yStd = std(y,0,2);
        tStd = std(t,0,2);
        tMean = mean(t,2);
        %tJit =  tStd ./ tMean;

%% Calculate correlation coefficient between various LTU BPMS.
for kk = 1:length(bpmYcouplingIndx)
        
        corf=corcoef(x(bpmXcouplingIndx,:),y(bpmYcouplingIndx(kk),:) );
        lcaPutSmart(couplingPV(kk), corf);
end
        %% Look for Burst mode DL2 BPM energy symetry problem
        bpmDl1Mean = 1000 * mean(bpmDl1x);
        bpmDl3Mean = 1000 * mean(bpmDl3x); %Microns

        symetricPart = (bpmDl1Mean + bpmDl3Mean) / 2;
        
        dispersionWavefromX = bpmDl2_eta* pFitX_DL1(:,1)';
        dispersionWavefromY = bpmDl2_eta* pFitY_DL1(:,1)';
        
        % Calculate max dispesion per region
        jj = 1;
        for ii = 1:length(regionIndx)
            maxPerRegion(jj) =   sum(abs(dispersionWavefromX(regionIndx{ii})));
            maxPerRegion(jj+1) = sum(abs(dispersionWavefromY(regionIndx{ii})));
            jj = jj+2;
        end

        plotIt = 0;
        if(plotIt)
            subplot(311), plot(z,[pFitX_DL1(:,1) pFitY_DL1(:,1)])
            subplot(312), plot(z,[xStd yStd])
            subplot(313), plot(z,tStd)
        end

         
        % Output to EPICS
        
        
        
        if ~debugOn 
            zP = 3000 * ones(1,175);
            zP(1:length(z)) = z;
            if beamOnBoth, lcaPutSmart('SIOC:SYS0:ML01:AO072',symetricPart); end
            lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM1', zP);
            if beamOnFirst,
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM2',  dispersionWavefromX);
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM3',  dispersionWavefromY);
                lcaPutSmart(perRegionPVs, maxPerRegion');
            end
            if beamOnBC1
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM6',   etaValAtBPM(1)* pFitX_BC1(:,1)');
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM7',   etaValAtBPM(1)* pFitY_BC1(:,1)');
            end
            if beamOnBC2
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM8',   etaValAtBPM(2)* pFitX_BC2(:,1)');
                lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM9',   etaValAtBPM(2)* pFitY_BC2(:,1)');
            end
            
           
            
            beamRate = lcaGetSmart('EVNT:SYS0:1:LCLSBEAMRATE');

            theToc = toc; 
            if beamRate < 9; beamRate = 10; end
            pause( max( (nMeas/beamRate) - theToc, 0) )
            %max( (nMeas/beamRate) - toc, 0)
        end
    %end
    
    continue
    
    % Now get DATA for all BSA PVs and calculate correlation coeff
    %%% Need to test: update dispersion at nMeas steps and energy jitter
    %%% data at 2800 but get data continously with edefOn...
    by2 = 2; %since data comes from 120 Hz file.
    %fprintf('\n CC %s\n', datestr(now))
    updateCC = 0;
    [numPVs, numPts] = size(the_matrix);
    
    i30=find(the_matrix(kp2(:), numPts/4+1)' == 0 );   % Mainly Laser Phase
    i60=find(the_matrix(kp2(:), numPts/2+1)' == 0 );   % Mainly PCAV Li25 and Li29 and TCAV Li24
    
    
    for i=1:size(i30,2)
        for isyn = 1:4
            ccd = corrcoef(the_matrix(kp2(i30(i)),1:numPts/4),the_matrix(ietaBPM ,isyn:4:numPts));
            ccdi(isyn)=ccd(1,2);
        end
        [maLP, isyngood]=max(ccdi);
    end

 for i=1:size(i60,2)
    for isyn = 1:2
        ccd = corrcoef(the_matrix(kp2(i60(i)),1:numPts/2),the_matrix(ietaBPM,isyn:by2:numPts)); 
        ccdi60(isyn)=ccd(1,2);
    end
    [maLP60(i), isyngood60(i)]=max(ccdi60.^2);
    [miLP60(i), isynnotgood60(i)]=min(ccdi60.^2); 
 end
 if ~isempty(i60)
     dataold60=the_matrix(kp2(i60),:);
     the_matrix(kp2(i60),isyngood60:2:numPts)=dataold60(:,1:numPts/2);
     the_matrix(kp2(i60),isynnotgood60:2:numPts)=dataold60(:,1:numPts/2);
 end
    
    
    ip=length(kp);
    for i=1:ip
        ccd =corrcoef(the_matrix(kp(i),1:by2:numPts),the_matrix(ietaBPM,1:by2:numPts));
 %       ccd =corrcoef(the_matrix(kp(i),2:by2:numPts),the_matrix(ietaBPM,1:by2:numPts-1 ));
        ccph(i)=ccd(1,2);
        ccd2=corrcoef(the_matrix(kp(i),1:by2:numPts),the_matrix(ietaBPM,1:by2:numPts ));  %506  232
        ccph2(i)=ccd2(1,2);
    end

    ip2=length(kp2);
    for i=1:ip2
        ccd =corrcoef(the_matrix(kp2(i),1:by2:numPts),the_matrix(ietaBPM,1:by2:numPts ));
        ccph(i+ip)=ccd(1,2);
        ccd2=corrcoef(the_matrix(kp2(i),1:by2:numPts),the_matrix(ietaBPM,1:by2:numPts ));
     %   ccd2=corrcoef(the_matrix(kp2(i),2:by2:numPts),the_matrix(ietaBPM,1:by2:numPts-1 ));  %506  232
        ccph2(i+ip)=ccd2(1,2);
    end
    kpall=[kp; kp2];
    ccphgood= ccph;
    ccphgood(isnan(ccphgood)) = 0;
    
    correlationCoeffPhase = ccphgood.^2;
   
    

    %write to history PVS.
    ccphOut = ccphgood.^2; 
    [xxdd,ksx]=sort(ccphOut,2,'descend');
    [o outIndx kpallIndx] = intersect(strrep(historyPvs,'ENERGYJITTER',''), DATA.root_name(kpall) );
    lcaPutSmart(historyPvs(outIndx), ccphOut(kpallIndx)');
    
    off_name= [{'Worst Device         Energy Jitter [%]'}; '  -  '; DATA.root_name(kpall(ksx(1:15)))];

    rmsE(1)= 100 * std(the_matrix(ietaBPM,1:1200))/ bpmDl2_eta; % in percent
    %rmsE(1)=std(the_matrix(ietaBPM,1:1200))/ 1.25;
    for i=1:length(xxdd)
        rmsE(i+1)=rmsE(i)*sqrt(1-xxdd(i));
    end
    rmsE=round(rmsE*1000) /1000;

    %%%Output to EPICS
    % 1- plot of ccph.^2 and ccph2.^2
    % 2- plot of xxdd*100 ylabel('Jitter Power [%]') xlabel('Worst Device #')
    % 3- Table of Worst Device and Energy jitter [%] from off_name and rmsE
    % 4- rmsE history to PVs
    jitterPower = zeros(1,175);
    jitterPower(1:length(xxdd)) = xxdd*100;
    lcaPutSmart('CUD:MCC0:BPMSWF:WAVEFORM10', jitterPower(1:175));
    makeTable(off_name,rmsE)
    
    % Table
    
    %Now make FFT waveform 
    if beamRate <119; continue, end
    Fs = 120; %Hz
     N = size(the_matrix,2);  
     N2 = N/2;
     [c, ia, ib] = intersect(bpmsToShow, DATA.root_name); %#ok<ASGLU>
     fftData = the_matrix(ib,:)';
     FFTdata = fft(fftData-ones(N,1)*mean(fftData));
     FFTdata = abs(FFTdata);
      FFTdata = FFTdata(1:1400,:); %Display 1/2
     df = Fs/N;                  %Resolution frequency 
     f = 0:df:Fs - df;         %Analysis frequencies
     fDsp = f(1:N2)';
     %write to EPICS
     lcaPutSmart('CUD:MCC0:BPMS_FFT:WAVEFORM1', fDsp');
     lcaPutSmart(fftWfPvs, FFTdata');
     
    catch
        disp('Error in loop...')
         rethrow(lasterror)
        keyboard
    end
end
end


function data = getBSA_names()
aidainit;
import edu.stanford.slac.aida.lib.da.DaObject;
da = DaObject();
v = da.getDaValue('LCLS//BSA.PVs.byZ');

% Extract the number of BSA element names returned (the number of rows)
Mrows = v.get(0).size(); 

% Extract just the element names and Z positions.
data.root_name = cellstr( (char(v.get(4).getStrings())) );
for ii = 1:length(data.root_name)
    data.nameTail{ii}  = data.root_name{ii}(end-1:end);
    data.nameTail1{ii} = data.root_name{ii}(end-8:end);
end
z_pos = (v.get(3).getStrings()); 
for i=1:Mrows
    z_positions(i) = str2double(z_pos(i,:));
end
data.z_positions = z_positions;
end

function makeTable(off_name,rmsE)
fileName = '/u1/lcls/matlab/config/engyCC';
fid = fopen(fileName,'w');
fprintf(fid,' begin\n numCols 2\n headerAlign "cc"\n align "rr"\n separators "      "\n');
fprintf(fid,' comment ";"\n end\n; Generated by bpmDisp.m\n');
%fprintf(fid,'%s\n', off_name{1});
for ii = 2:15
    fprintf(fid,'%s     %.4f\n', off_name{ii}, rmsE(ii-1));
end
fclose(fid);
lcaPutSmart('SIOC:SYS0:ML01:AO071.DESC', fileName);
end

function [the_matrix root_name kx ky kt kp kp2 ki kv] = getMat_BSAGUIfile
baseDir =[ '/u1/lcls/matlab/data/' datestr(now,'yyyy/') datestr(now,'yyyy-mm/') datestr(now,'yyyy-mm-dd/')]; 
files = dir([baseDir 'BSA-data*.mat']);
% I = find(files.datenum == max(files.datenum)); %Finds newest file by date files(I).name %gives name of newest file
filenew = [baseDir files(end).name];
load(filenew)
%load('/u1/lcls/matlab/data/2012/2012-11/2012-11-02/BSA-data-2012-11-02-162635.mat') 
the_matrix = data.the_matrix;
root_name = data.ROOT_NAME';
for ii = 1:length(root_name), nameTail{ii}  = root_name{ii}(end-1:end); end
kx = strmatch(':X',nameTail);
ky = strmatch(':Y',nameTail);
kt = strmatch('IT',nameTail);
kp = strmatch('ST',nameTail);
kp2 = [strmatch(':A',nameTail); strmatch(':P', nameTail); strmatch('_A',nameTail); strmatch('_P', nameTail)];
ki = strmatch('AX', nameTail);
kv = strmatch('LT', nameTail);
end

function corf=corcoef(xdata,ydata)
% calculates correlation coefficient from xdata and ydata
% returns it in 'corf'
N=length(xdata);
corf=(N*sum(xdata.*ydata)-sum(xdata)*sum(ydata))/...
	sqrt((N*sum(xdata.*xdata)-(sum(xdata))*(sum(xdata)))*...
	(N*sum(ydata.*ydata)-(sum(ydata))*(sum(ydata))));
end

% %%
% val = [];
%  np = 20:10:1000;
% for npts = 20:10:1000
%     xdata = x(1:npts);
%     ydata = y(3,1:npts);
%     N=length(xdata);
%     corf=(N*sum(xdata.*ydata)-sum(xdata)*sum(ydata))/...
% 	sqrt((N*sum(xdata.*xdata)-(sum(xdata))*(sum(xdata)))*...
% 	(N*sum(ydata.*ydata)-(sum(ydata))*(sum(ydata))));
%     val = [val, corf]; 
% end
% figure, plot(np,val)
% 
%     



