function[] = calCavityBpmMain(simvar)
%   calCavityBpmMain.m
%
%   This script is used to acquire calibration data (and optionally implement a new
%    calibration) for the LCLS cavity BPMs located in undulator hall and at
%    the end of the LTU.
%   Calibration parameters consist of X and Y position scaling factors (USCL and VSCL),
%    X and Y signal detector phases (UPHAS and VPHAS), and two angles used to parametrize
%    the coupling between the X and Y planes (PHI and PSI).
%
%   This script is launched by an edm display shell command from bpm_cal_data_acq.edl.
%
%   Use bpm_cal_data_acq.edl to select which BPMs in which planes to calibrate.
%   From that display you can also select a 'short' (2 steps, 100 um) or
%   'standard' (4 steps, 200 um) scan type.
%
%   The first two BPMs are not on movers, so LTU correctors are used to calibrate these.
%   The remaining BPMs are calibrated by moving the girders using the girderBPMMove
%   matlab function. The exception to this is the first BPM in the undulator; it is
%   located on the upstream end of the girder and girderBFWMove is used to move it.
%
%   For the girder BPMs, jitter is compensated for by using upstream BPMs.
%
%
% optional single argument to execute program without 
% taking any invasive actions
sim = 0;
if ( exist('simvar', 'var') )
   sim = simvar;
end  

tic;

calInit;
if ( ~init )
    return;
end

% Acquire jitter correction data (used for undulator BPMs)
try
    lcaPut( msg_pv, 'Acquiring jitter correction data' );
    e = 0; n = 1;
        
    jdata = zeros( nbpms, NSIGNALS, NSAMPLES );
    while n <= NSAMPLES
        newdata = 1;
        try lcaNewMonitorWait( mon_pv )
        catch ME
            disp( 'Timeout waiting for new data' );
            e = e + 1;
            newdata = 0;
        end
        
        if newdata
            [dataSet, e, skipPoint] = calGetData( bpm_pv, nbpms, acc, e );
            if ( ~skipPoint )                
                jdata(:,:,n) = dataSet;
                n = n + 1;
            end                        
        else
            if ( calCheckRate ) % PVs did not update; check beam rate
                restore_mask = bitor( restore_mask, RESTORE_QUIT );
                calRestore;
            end
        end
        
        if ( e > NPULSESABORT )
            promptstr = 'No beam or bad status.';
            if calPromptContinue( 0, promptstr )
                restore_mask = bitor( restore_mask, RESTORE_QUIT );
                calRestore;
            end
            e = 0;
        end
    end
    
    % Quit if abort requested
    if ( lcaGet( abort_pv, 0, 'float' ) )
        restore_mask = bitor( restore_mask, RESTORE_QUIT );
        calRestore;
    end
    
    % For each undulator BPM, choose which BPMs to use for jitter
    % correction, taking into account which BPMs are online
    % (Do not perform jitter correction for the non-undulator BPMs)
    for j = RFBU00:nbpms
 
        if ( sel(j) && ~bitand( err(j), ERR_SKIP ) )
            if ( j == RFBU01 ) % Special case: RFBU00 on same girder; use upstream BPMs instead
                if ( acc(j-2) || acc(j-3) ) % If either upstream BPM not online, cannot calibrate RFBU01
                    err(j) = bitor( err(j), ERR_INSUFF);
                else
                    bpm(j).p1 = j - 2 ;
                    bpm(j).p2 = j - 3 ;
                end
            elseif ( j == RFBU34 ) % Special case: RFBU33 on same girder; use upstream BPMs instead
                for k=j-2:-1:1
                    if ( ~bpm(j).p1 )
                        if ( ~acc(k) )
                            bpm(j).p1 = k;
                        end
                    elseif ( ~bpm(j).p2 )
                        if ( ~acc(k) )
                            bpm(j).p2 = k;
                        end
                    end
                end
                if ( ~bpm(j).p1 || ~bpm(j).p2 )
                    err(j) = bitor( err(j), ERR_INSUFF);
                end
                for k=j-2:-1:1
                    if ( ~bpm(j).p1 )
                        if ( ~acc(k) )
                            bpm(j).p1 = k;
                        end
                    elseif ( ~bpm(j).p2 )
                        if ( ~acc(k) )
                            bpm(j).p2 = k;
                        end
                    end
                end
                if ( ~bpm(j).p1 || ~bpm(j).p2 )
                    err(j) = bitor( err(j), ERR_INSUFF);
                end
            else
                for k=j-1:-1:1
                    if ( ~bpm(j).p1 )
                        if ( ~acc(k) )
                            bpm(j).p1 = k;
                        end
                    elseif ( ~bpm(j).p2 )
                        if ( ~acc(k) )
                            bpm(j).p2 = k;
                        end
                    end
                end
                if ( ~bpm(j).p1 || ~bpm(j).p2 )
                    err(j) = bitor( err(j), ERR_INSUFF);
                end
            end
    
            if ( ~bitand( err(j), ERR_INSUFF) )
                prevXY = squeeze([jdata(bpm(j).p1,X,:); jdata(bpm(j).p2,X,:); ...
                    jdata(bpm(j).p1,Y,:); jdata(bpm(j).p2,Y,:)]);
                % Find fit coefficients to predict this BPM from upstream BPMs
                [~, bpm(j).cudj] = calLinearPredictor( jdata(j,URER,:) + jdata(j,UIMR,:)*i, prevXY );
                [~, bpm(j).cvdj] = calLinearPredictor( jdata(j,VRER,:) + jdata(j,VIMR,:)*i, prevXY );
            end
        end
    end
    
    lcaPut( err_pv, err ); %#ok<*USENS>
    
    if ( lcaGet( abort_pv, 0, 'float' ) )
        restore_mask = bitor( restore_mask, RESTORE_QUIT );
        calRestore;
    end
    
catch ME
    dbstack();
    msg = 'Error during jitter acq. Quitting.';
    disp( msg );
    lcaPut( msg_pv, msg );
    calRestore;
    return;
end
    
% Calibrate girder BPMs
if ( any( sel(3:nbpms) ) )
   try
        % Set flags for first BPM/plane to indicate that
        % there is no previous girder move to restore
        prevBpm   = 0;
        prevPlane = 0;
        prevGirder = 0;
        restore_mask = bitor( restore_mask, RESTORE_GRDR );
        
        for j = RFBU00:nbpms
            
            % Determine which planes to scan based on user's selections
            [bpmsel, a, b] = selPlanes( sel(j), sel(j) );
            
            % Only scan if BPM selected 
            if ( bpmsel )
                % Only scan if no reason to skip
                if ( ~thisBpmSkipped( err(j), ERR_SKIP) )
                    % Scan until BPM done, too many failed attempts, or other error
                    done = 0;
                    while ( ~done )
                        [bpm(j),prevBpm,prevPlane,prevGirder] = calScanGirder( a, b, bpm(j), j, ...
                            mov, prevBpm, prevPlane, prevGirder, mon_pv, bpm_pv, nbpms, acc, z, prog_pv, NSTEPS, restore_mask, err );
                        
                        % Calculate calibration parameters and assess success
                        if ( ~thisBpmSkipped( err, j ) )
                            
                            [uscl(j),vscl(j),uv(j),vu(j),uphas(j),vphas(j),ur(j),vr(j),bpm(j),xbaddata,ybaddata] = ...
                                calCookData( j, 1, bpms{j}, plotf, uscl_i(j), vscl_i(j), c, bpm(j), ur(j), vr(j), ...
                                                uscl(j), vscl(j), uphas(j), vphas(j), uv(j), vu(j));
                            
                            err(j) = getScanError( xbaddata,  ybaddata, bpm(j), err(j), ur(j), vr(j) );
                            lcaPut( err_pv{j}, err(j) );
                            
                            % Determine if need to scan again and if so, which planes
                            done = (ur(j) && vr(j)) || thisBpmSkipped( err, j );
                            if (~done)
                                [~,a,b] = selPlanes( ~ur(j), ~vr(j) );
                            end
                        end
                    end
                    [phi(j),psi(j)] = calCouplingWrapper( ur(j), vr(j), uv(j), vu(j), phi(j), psi(j) );                    
                end
                lcaPut( prog_pv{j}, PROG_SCANDONE ); % move this to better place
            end
        end
        
        % Restore the final move (if any girders were moved)
        if ( prevPlane )
            lcaPut( msg_pv, 'Restoring girder moves' );
            if ( prevPlane == XPLANE )
                xmovLast = mov.restore;
                ymovLast = 0;
            else
                xmovLast = 0;
                ymovLast = mov.restore;
            end
            if ( prevBpm == RFBU00 )
                girderBFWMove( prevGirder, xmovLast, ymovLast );
            else
                girderBPMMove( prevGirder, xmovLast, ymovLast );
            end
            status = girderCamWaitLess( prevGirder );
            if ( ~status )
                err(prevBpm) = bitor( err(prevBpm), ERR_GIRDER );
                lcaPut( err_pv{prevBpm}, err(prevBpm) );
            end
        end
        
    catch ME
       msg = 'Error: see Matlab console for details';
       lcaPut( msg_pv, msg );
       dbstack();
       calRestore;
       return;
    end
end

if ( lcaGet( abort_pv, 0, 'float' ) )
    restore_mask = bitor( restore_mask, RESTORE_QUIT );
    calRestore;
end

% Temporary safety save until this version fully tested
try
path_name=('/u1/lcls/physics/cavityBPM/calibration/data/backup/');
date=datestr(now,31);
str = ['BPMCalib','_',date(1:10),'_',date(12:13),'_',date(15:16)] ;
save(fullfile(path_name,str))
fprintf('All variables saved to %s%s.mat\n\n',path_name,str); 
catch
end

% Write calibration parameters to girder BPMs
if ( any( ur(RFBU00:nbpms) ) || any( vr(RFBU00:nbpms) ) )
    wsel = sel; 
    wsel(1:2) = 0;
    [tmp,err] = calPromptWriteParms(bpms, gain_pv, gain, wsel, ...
        wsel_pv, uscl, uscl_i, vscl, vscl_i, uphas, vphas, phi, psi,  ...
        ur, vr, err, err_pv, restore_mask);
    wstat = max( tmp, wstat ); %#ok<*NODEF>
end
   
% Calibrate non-girder BPMs
try
    % Only scan if either BPM selected and no reason to skip   
    bpmsel = sel(RFB07:RFB08); 
    if ( any(bpmsel) && (~thisBpmSkipped( err, RFB07 ) || ~thisBpmSkipped( err, RFB08 )) )
       
        [rfbu07_8_predBPMs, bpm] = calNonGirderBpmSetupPred( bpms, bpm, nbpms, acc, sel, prog_pv );
        
        % If we have found enough online downstream BPMs for position prediction
        if ( all( rfbu07_8_predBPMs ) )
            
            % Flag to restore correctors at end of program
            restore_mask = bitor( restore_mask, RESTORE_COR );
            
            % Scan both planes
            a = 1; b = 2;
            
            % Scan until both BPMs done, too many failed attempts, or other error
            done = 0;
            while ( ~done )
                
                bpm = calScanNonGirder( a, b, cor, mon_pv, bpm_pv, nbpms, acc, rfbu07_8_predBPMs, bpm, restore_mask, bpmsel, NPOINTSCOR ); % Acquire data       
                
                % Calculate calibration parameters and assess success
                for j = RFB07:RFB08   
                    if ( sel(j) && ~thisBpmSkipped( err, j ) )
                        [uscl(j),vscl(j),uv(j),vu(j),uphas(j),vphas(j),ur(j),vr(j),bpm(j), xbaddata, ybaddata] = ...
                            calCookData( j, 0, bpms{j}, plotf, uscl_i(j), vscl_i(j), c, bpm(j), ur(j), vr(j), ...
                                            uscl(j), vscl(j), uphas(j), vphas(j), uv(j), vu(j) );
                        err(j) = getScanError( xbaddata,  ybaddata, bpm(j), err(j), ur(j), vr(j) );
                    end 
                end
                
                % Determine if need to scan again and if so, which BPMs and which planes
                [done,a,b,bpmsel] = nonGirderPlanScan(ur,vr,err,bpmsel);
                
                if ( lcaGet( abort_pv, 0, 'float' ))
                    restore_mask = bitor( restore_mask, RESTORE_QUIT );
                    calRestore;
                end
            end
        else
            for k = RFB07:RFB08
                err(k) = setErr( err(k), ERR_INSUFF );
            end
        end
        lcaPut( err_pv, err );
    end
    
    for j=RFB07:RFB08
        if ( sel(j) )
            [phi(j),psi(j)] = calCouplingWrapper( ur(j), vr(j), uv(j), vu(j), phi(j), psi(j) );
            lcaPut( prog_pv{j}, PROG_SCANDONE );
        end
    end
    
catch ME
    dbstack;
    msg = 'Error, see matlab console';
    lcaPut( msg_pv, msg );
    calRestore;
    return;
end 

% Temporary safety save until this version fully tested
try
path_name=('/u1/lcls/physics/cavityBPM/calibration/data/backup/');
date=datestr(now,31);
str = ['BPMCalib','_',date(1:10),'_',date(12:13),'_',date(15:16)] ;
save(fullfile(path_name,str))
fprintf('All variables saved to %s%s.mat\n\n',path_name,str); 
catch
end

try
    if ( lcaGet( abort_pv, 0,'float' ) )
        restore_mask = bitor( restore_mask, RESTORE_QUIT );
        calRestore;
    end

    elapsed = toc; %#ok<*NASGU>

    % Write calibration parameters to non-girder BPMS
    if ( any( ur(RFB07:RFB08) ) || any( vr(RFB07:RFB08) ) )
        wsel = sel; wsel(RFBU00:nbpms) = 0;
        [tmp,err] = calPromptWriteParms(bpms, gain_pv, gain, wsel, ...
            wsel_pv, uscl, uscl_i, vscl, vscl_i, uphas, vphas, phi, psi,  ...
            ur, vr, err, err_pv, restore_mask);
        wstat = max( tmp, wstat );
    end
           
    calLogMsg( 'Cavity BPM calibration complete' );
    calPlotScale( ur, uscl, uscl_i, vr, vscl, vscl_i, nbpms, sel ) ;
    calRestore;
    calSaveFile;
    msg = 'Calibration complete';
    lcaPut( msg_pv, msg );
    endmsg = calLogSum( wstat );
    choice=questdlg(endmsg,'Cavity BPM Calibration complete. Exit Matlab?',...
        'Close all windows and exit','Stay open','Close all windows and exit');
    switch choice
        case 'Close all windows and exit'
            quit;
        case 'Stay open'
    end
        
catch ME
    msg = 'Error: see Matlab console for details';
    disp( msg );
    lcaPut( msg_pv, msg );
    dbstack();
    calRestore;
    return;
end
end

%----End of calCavityBpmMain; begin supporting functions----%


function[err] = setErr( err, newerr )
%
%   Or new error bit(s) into error mask for jth BPM
%
err = bitor( err, newerr );
end

function[rval] = thisBpmSkipped( err, j )
%
%   Return 1 if this BPM has 'skip' bit set in error mask
%   Else return 0
%
calHeader;
rval = bitand( err(j), ERR_SKIP );
end

function[rval, err] = calPromptWriteParms(bpms, gain_pv, gain, wsel,  ...
    wsel_pv, uscl, uscl_i, vscl, vscl_i, uphas, vphas, phi, psi,  ...
    ur, vr, err, err_pv, restore_mask)
%
%
%
calHeader;

nbpms = length( bpms );

% If BPM cal failed, set the select bit to 0 
% so that calPlotScale does not plot it
tmpwsel = wsel;
for j=1:nbpms
    if ( tmpwsel(j) )
        if ( thisBpmSkipped( err, j ) )
            tmpwsel(j) = 0;
        end
    end
end
calPlotScale( ur, uscl, uscl_i, vr, vscl, vscl_i, nbpms, tmpwsel );

lcaPut( msg_pv, 'Awaiting user input' );

choice = questdlg( 'Would you like to implement these changes?', ...
    'Implement Calibration?', 'Yes', 'Partial', 'No', 'Yes' );

switch choice
    case 'Yes'
        [rval,err] = calWriteParms(bpms, gain_pv, gain, wsel, ...
            uscl, vscl, uphas, vphas, phi, psi, ur, vr, err, err_pv, restore_mask);

    case 'Partial'
        reply = questdlg( 'Select the BPMs you would like to calibrate from the Plotting and Implementing Calibration Display and then hit Go', ...
            'Implement Partial Calibration?', 'Go', 'Cancel', 'Go' );
        switch reply
            case 'Go'
                [rval,err] = calWriteParms(bpms, gain_pv, gain, ...
                    lcaGet( wsel_pv ), uscl, vscl, ...
                    uphas, vphas, phi, psi, ur, vr, err, err_pv, restore_mask);                
            case 'Cancel'                
        end
    case 'No'
        rval = RVAL_SUCC;

end

end

function[endmsg] = calLogSum(rval)
%
%    Based on rval, determine final message and print to logbook
%
if ( rval == 0 )
    endmsg = 'Implemented calibration and printed plot of scale changes to logbook';
    util_printLog_wComments( 1000, 'BPMCAL', 'Cavity BPM Calibration Scale Changes ', ' ', [1100 650] );
elseif ( rval > 0 )
    endmsg = 'Calibration completed with errors (see EDM screens).';
    util_printLog_wComments (1000, 'BPMCAL', 'Cavity BPM Scale Changes ', ' ', [1100 650] );
else
    endmsg = 'Failed to implement calibration';
end

end

function[calquit] = calCheckRate
%
%   Check the beam rate. If the rate is zero, it calls 
%   calBeamRateWait; else it waits for the next beam pulse.
%
%   This script is called by calCavityBPMMain 

calquit = 0; 
rate = lcaGet('EVNT:SYS0:1:LCLSBEAMRATE');
if rate==0
    calquit = calBeamRateWait(rate);
else
    pause(1/rate)
end

end

function[calquit] = calPromptContinue(abort, promptstr)
%
%   Called when calCavityBPMMain identifies an error.
%   It prompts the user to continue. If the user chooses not to continue
%   set calquit to 1 and return
%
%   To do: make prompstr optional

calquit=0;

if abort
    choice = 'No';
else
    choice=questdlg([promptstr ' Do you want to continue?'],'Continue BPM Calibration?','Yes','No','Yes');
end

switch choice
    case 'No'
        calquit=1;
    case 'Yes'
end

end

function[calquit] = calBeamRateWait(rate)
%
%   Called when calCavityBPMMain identifies zero beam rate.
%   It waits 30 seconds for the rate to return. If it does not, it calls
%   calPromptContinue to prompt the user to choose to continue or exit.
%

g=1; 

while rate==0 &&  g<30
    pause(1);g=g+1;rate=lcaGet('EVNT:SYS0:1:LCLSBEAMRATE');
end

if g==30
    promptstr = 'Timeout due to zero beam rate.';
    calquit = calPromptContinue(0, promptstr);
end

end

function[phi,psi] = calCouplingWrapper(ur,vr,uv,vu,phi,psi)
%       calCouplingWrapper
%
%       If both planes were selected and calibrated, call calCoupling
%       to calculate coupling between planes. If not, leave phi/psi at
%       initial values. 
%
%       Arguments:
%                   for uv/vu see calCoupling
%                   ur  - 1 if BPM calibrated in X
%                   vr  - 1 if BPM calibrated in Y
%                   phi - initial phi value
%                   psi - initial psi value
%
%       Return:
%                   phi - new phi value
%                   psi - new psi value
%                           
    
% Calculate coupling if both x and y planes have been calibrated
if ( ur && vr) 
    [phi,psi] = calCoupling( uv, vu );
end
end

function[phi,psi] = calCoupling(uv,vu)
% 
%       calCoupling
%
%       Calculate coupling for single BPM
%
%       Return two angles which parametrize the coupling:
%           phi = angle BPM axes are rotated from true x/y
%           psi = angle between BPM axes
%       If there is no coupling, phi=45 deg, psi=90 deg.
%
%       Arguments:
%                   uv - uvscl/uscl
%                   vu - vuscl/vscl where:
%
%           uscl = x scale factor
%           vscl = y scale factor
%           uvscl = measured y change for x beam position move
%           vuscl = measured x change for y beam position move
%
%           phi = -asin-1(vu)
%           theta = -asin-1(uv)
%           psi = pi/2 + phi + theta
%

phi = (-asin(vu))*(180/pi);
theta = (-asin(uv))*(180/pi);
psi = 90 + phi + theta;

end

function[sel,a,b] = selPlanes(xsel, ysel)
%
%       selPlanes
%       
%       Determine whether this BPM selected and in which planes
%       
%       Arguments:
%                   xsel - flag indicating whether selected in X plane
%                   ysel - flag indicating whether selected in Y plane
%       Return:
%                   sel  - flag indicating whether selected in either plane
%                   a    - Starting value in X/Y loop, XPLANE if X is selected,
%                          YPLANE if only Y is selected, 0 if neither selected
%                   b    - Ending value in X/Y loop, XPLANE if only X is selected,
%                          YPLANE if Y is selected, 0 if neither selected
calHeader;

a = xsel;
b = ysel;
sel = (a || b );

if ( sel )
    if ( a && b )
        a = XPLANE;
        b = YPLANE;
    elseif ( a )
        a = XPLANE;
        b = XPLANE;
    else
        a = YPLANE;
        b = YPLANE;
    end
else
    a = 0;
    b = 0;
end

end

function[rData] = calSelOrderXYData(data, varargin)
%
%       calSelOrderXYData
%
%       Given 2-D data set and optional vector specifying which rows to 
%       use, select rows from data and create 1-D vector of X and Y signals,  
%       in the following order:
%
%       rowa X
%       rowa Y
%       rowb X
%       rowb Y
%       .
%       .
%       .
%
%       Argument:
%                   data      2-D data set (rows are BPMS, cols are signals)
%
%   	Optional Argument:
%                   varargin  Vector whose element values are which rows of data
%                             to include
%
%       Return:
%                   rData     Selected, ordered X Y data vector
%
calHeader;

if (length(varargin) == 1)
    vec = varargin{1};
    selData = data( vec, : );
else
    selData = data;
end
    
[r,~] = size( selData );

rData = zeros( 2*r, 1 );

for j = 1:r
    rData(j*2 - 1) = selData(j,X);
    rData(j*2)     = selData(j,Y);
end

end

function[e, skipPoint] = calDataErrors(rerr, e, nan, tdiff )
%       calChkData
%
%       Check data set for consistent timestamps and to make sure
%       no data points are not-a-number. Update error count, and 
%       determine if point should be skipped.
%
%       Argument:
%                   rerr      return val from data get, 0 if success
%                   e         error count
%                   nan       Non-zero if any values are not-a-number
%                   tdiff     Non-zero if any timestamps differ
%
%       Return:
%                   e         updated error count
%                   skipPoint flag to skip data point

skipPoint = 1;

if ( rerr )
    e = e + 1;
else
    if ( tdiff ) % Timestamps don't match
    elseif ( nan ) % Invalid data or error during get
        e = e + 1;
    else
        skipPoint = 0;
    end
end

end

function[nan, tdiff] = calChkData(dataSet, dataSetTs, acc)
%
%       calChkData
%
%       Check data set for consistent timestamps and to make sure
%       no data points are not-a-number. Call calDataErrors to 
%       update pulse count, error count, and determine if point should be
%       skipped.
%
%       Argument:
%                   dataSet   data
%                   dataSetTs timestamps from data
%                   acc       vector of which rows to use for data
%                             integrity checks
%
%       Return:
%                   nan       Non-zero if any values are not-a-number
%                   tdiff     Non-zero if any timestamps differ
%
select  = not(acc);
selData = dataSet(select,:); % Select only data for online BPMs
selTs   = dataSetTs(select,:);

time = mod(real(selTs),60) + imag(selTs)/1e9;

tdiff = (max(max(time)) ~= min(min(time)));

nan = max(max( isnan( selData ) ));

end

function[dataSet, e, skipPoint] = calGetData(bpm_pv, nbpms, acc, e)
%
%   Acquire data from bpm_pv and  and convert
%   timestamps to seconds and fraction
%
%                   acc       vector of which rows to use for data
%                             integrity checks
%                   e         error count
%       Return:
%                   dataSet   data
%                   e         updated error count
%                   skipPoint flag to skip data point
%

rerr = 0;

try
    [d ts]=lcaGet( bpm_pv );
catch ME
    rerr = 1;
    dataSet = 0;
    dataSetTs = 0;
    return;
end

calHeader

dataSet(:,URER)   =  d(1+nbpms*(URER-1):nbpms*URER);
dataSetTs(:,URER) = ts(1+nbpms*(URER-1):nbpms*URER);

dataSet(:,UIMR)   =  d(1+nbpms*(UIMR-1):nbpms*UIMR);
dataSetTs(:,UIMR) = ts(1+nbpms*(UIMR-1):nbpms*UIMR);

dataSet(:,VRER)   =  d(1+nbpms*(VRER-1):nbpms*VRER);
dataSetTs(:,VRER) = ts(1+nbpms*(VRER-1):nbpms*VRER);

dataSet(:,VIMR)   =  d(1+nbpms*(VIMR-1):nbpms*VIMR);
dataSetTs(:,VIMR) = ts(1+nbpms*(VIMR-1):nbpms*VIMR);

dataSet(:,X)      =  d(1+nbpms*(X-1):nbpms*X);
dataSetTs(:,X)    = ts(1+nbpms*(X-1):nbpms*X);

dataSet(:,Y)      =  d(1+nbpms*(Y-1):nbpms*Y);
dataSetTs(:,Y)    = ts(1+nbpms*(Y-1):nbpms*Y);

[nan, tdiff] = calChkData( dataSet, dataSetTs, acc );
[e, skipPoint] = calDataErrors(rerr, e, nan, tdiff );

end

function[bpm] = calNonGirderBpmGetRmat(bpms, bpm, rfbu07_8_predBPMs)
%
%   Get R-matrices between BPMs to calibrate and BPMs
%   to use in prediction calculation. 
%
%
calHeader;

predDataBPMs = cell( NPREDBPMS, 1 );
for k=1:NPREDBPMS
    predDataBPMs{k} = bpms{rfbu07_8_predBPMs(k)};
end

for j = RFB07:RFB08
    % From Henrik: use downstream BPM data and R-matrices between those 
    % and RFB07/RFB08 to predict position at RFB07/08
    r = model_rMatGet( bpms{j}, predDataBPMs );
    bpm(j).r13 = reshape( permute( r([1 3],1:4,:) ,[1 3 2] ), [], 4 );

end

end

function[rfbu07_8_predBPMs, bpm] = calNonGirderBpmSetupPred(bpms, bpm, nbpms, acc, sel, prog_pv)
%
%   For non-girder BPMs choose which downstream BPMs to use for 
%   position prediction. Call calNonGirderBpmGetRmat to get
%   R-matrices between BPMs. Set progress PV to indicate calibration 
%   in progress.

calHeader;

rfbu07_8_predBPMs = zeros( 1, NPREDBPMS );
predBPMsAvail = ones( 1, nbpms );

for j=1:NPREDBPMS
    if ( ~rfbu07_8_predBPMs(j) )
        for k=RFBU00:(nbpms - 1) % do not use RFBU34, hence nbpms - 1
            if ( ~acc(k) && predBPMsAvail(k) )
                rfbu07_8_predBPMs(j) = k;
                predBPMsAvail(k) = 0;
                break;
            end
        end
    end
end

bpm = calNonGirderBpmGetRmat( bpms, bpm, rfbu07_8_predBPMs );

for j = RFB07:RFB08
    if ( sel(j) )
        lcaPut( prog_pv{j}, PROG_SCAN );
    end
end

end

function[err] = getScanError(xbaddata, ybaddata, bpm, err, xdone, ydone)
%
%   Set error flags, based on scan results
%
calHeader;

if ( xbaddata )                % If x failed because of bad data fit
    if ( bpm.ntriesX >= NRETRIES ) % If we've already tried x NRETRIES times, skip this BPM
        err = setErr( err, ERR_BADFIT );
    end
elseif ( ybaddata )            % If y failed because of bad data fit
    if ( bpm.ntriesY >= NRETRIES )  % If we've already tried y NRETRIES times, skip this BPM
        err = setErr( err, ERR_BADFIT );
    end
elseif ( ~xdone ) % If x failed because of other reason, skip this BPM
    err = setErr( err, ERR_CALCX );    
elseif ( ~ydone ) % If y failed because of other reason, skip this BPM
    err = setErr( err, ERR_CALCY );
end

end

function[done,a,b,bpmsel] = nonGirderPlanScan(ur,vr,err,bpmsel)
%
%   For non-girder BPMs, use recent scan results to determine
%   if need to do another and if so, in which planes
%
calHeader;

rfb07_done = (ur(RFB07) && vr(RFB07)) || thisBpmSkipped( err, RFB07) || ~bpmsel(RFB07);
rfb08_done = (ur(RFB08) && vr(RFB08)) || thisBpmSkipped( err, RFB08) || ~bpmsel(RFB08);
done = rfb07_done && rfb08_done;

if (~done)
    udone = (ur(RFB07) || thisBpmSkipped( err, RFB07 )) && (ur(RFB08) || thisBpmSkipped( err, RFB08 ));
    vdone = (vr(RFB07) || thisBpmSkipped( err, RFB07 )) && (vr(RFB08) || thisBpmSkipped( err, RFB08 ));
    [~,a,b] = selPlanes( ~udone, ~vdone );
    bpmsel(RFB07) = ~rfb07_done;
    bpmsel(RFB08) = ~rfb08_done;
else
    a = 1; % Set to default values so function call succeeds, but 
    b = 2; % these values will not be used because these BPMs are done
end

end
   
function[bpm] = storeDataX(bpm,p,dataSet,j)

calHeader;
bpm.dataX(XPLANE,p) = dataSet(j,URER) + 1i*dataSet(j,UIMR);
bpm.dataX(YPLANE,p) = dataSet(j,VRER) + 1i*dataSet(j,VIMR);

end

function[bpm] = storeDataY(bpm,p,dataSet,j)

calHeader;
bpm.dataY(XPLANE,p) = dataSet(j,URER) + 1i*dataSet(j,UIMR);
bpm.dataY(YPLANE,p) = dataSet(j,VRER) + 1i*dataSet(j,VIMR);
end

function[girderVec] = getGirderPositionVector(j,bpm,z)

calHeader;

if ( j == RFBU00 ) % RFBU00 has different girder coordinates
    girderVec = girderAxisFind( bpm.girder, z.bpm00, 0 );
elseif ( j == RFBU34 ) % RFBU34 has different girder coordinates
    girderVec = girderAxisFind( bpm.girder, z.bpm34, 0 );
else
    girderVec = girderAxisFind( bpm.girder, z.bpm, 0 );
end

end

function[segmentList,xmovList,ymovList] = planGirderMoves(j,segmentList,m,mov,k,prevBpm,prevPlane,prevGirder)

% For next move, create list of girders and their move planes/sizes
% If previous BPM was special case RFBU00, restore it to original
% segmentList is girders to wait for later; this list is augmented if
% we are also restoring the previous girder

calHeader;

if ( m == XPLANE )
    xmov  = mov.steps(k);
    ymov  = 0;
elseif ( m == YPLANE )
    xmov  = 0;
    ymov  = mov.steps(k);
end

% Girder moves to make later; this list is augmented if
% we are also restoring the previous girder
xmovList = xmov;
ymovList = ymov;

% If this is NOT our first BPM and first plane and it IS the first
% step, determine what needs to be restored from the last move
if ( (k == 1) && (prevBpm ~= 0) )
    if ( prevPlane == XPLANE )
        xmovLast = mov.restore;
        ymovLast = 0;
    elseif ( prevPlane == YPLANE )
        xmovLast = 0;
        ymovLast = mov.restore;
    end
    if ( j == prevBpm )
        xmovList = xmov + xmovLast;
        ymovList = ymov + ymovLast;
    else
        if ( prevBpm == RFBU00 )
            girderBFWMove( prevGirder, xmovLast, ymovLast );
            girderCamWaitLess( 1 );
        else
            % When moving girder 1 with others,
            % girder 1 must be first in the list
            segmentList = [prevGirder, segmentList];
            xmovList    = [xmovLast; xmov];
            ymovList    = [ymovLast; ymov];
        end
    end
end
end

% calScanGirder
function[bpm,prevBpm,prevPlane,prevGirder] = calScanGirder(a,b,bpm,j,mov,prevBpm,prevPlane,prevGirder,mon_pv,bpm_pv,nbpms,acc,z, prog_pv, NSTEPS,restore_mask, err)

calHeader;

for m=a:b
    if ( lcaGet( abort_pv, 0, 'float' ) )
        restore_mask = bitor( restore_mask, RESTORE_QUIT );
        calRestore;
    end
    lcaPut( prog_pv{j}, PROG_SCAN );
    tstatus = 1; % Initialize girder move status to success
    lcaPut( msg_pv, ['Moving girder '  num2str( bpm.girder )] );
    
    for k = 1:NSTEPS

        [segmentList,xmovList,ymovList] = planGirderMoves( j, bpm.girder, m, mov, k, prevBpm, prevPlane, prevGirder );
        
        e = 0; % Initialize error count
        n = 1; % Initialize sample number
        
        if ( j == RFBU00 )
            girderBFWMove( segmentList, xmovList, ymovList );
        else
            girderBPMMove( segmentList, xmovList, ymovList );
        end
        status  = girderCamWaitLess( segmentList );
        tstatus = min( tstatus, status) ; % Capture any girder move errors
        
        while n <= NSAMPLES
            newdata = 1;
            try lcaNewMonitorWait( mon_pv )
            catch ME
                disp( 'Timeout waiting for new data' );
                e = e + 1;
                newdata = 0;
            end
            if ( newdata )
                [dataSet, e, skipPoint] = calGetData( bpm_pv, nbpms, acc, e );
                if ( ~skipPoint )
                    
                    xydata = calSelOrderXYData( dataSet );
                    
                    girderVec = getGirderPositionVector( j, bpm, z );

                    p = NSAMPLES*(k-1) + n; % Point number
                    % Copy data and calculate x, x', y, y' vector at BPM
                    % bpm.dataX/Y: | urer +iuimr, ... |  bpm.bpmVecX/Y:   | x |
                    %              | vrer +ivimr, ... |                   | x'|
                    %                                                     | y |
                    %                                                     | y'|
                    %          data points -> ...
                    if ( m == XPLANE )
                        bpm = storeDataX( bpm, p, dataSet, j );
                        bpm.xydataX(:,p) = xydata;
                        bpm.bpmVecX(:,p) = [-girderVec(1)/1000;0;0;0]; % [m]
                    elseif ( m == YPLANE )
                        bpm = storeDataY( bpm, p, dataSet, j );
                        bpm.xydataY(:,p) = xydata;
                        bpm.bpmVecY(:,p) = [0;0;-girderVec(2)/1000;0]; % [m]
                    end
                    n = n + 1;
                end
            else
                if ( calCheckRate || (lcaGet(abort_pv,0,'float')) )
                    restore_mask = bitor( restore_mask, RESTORE_QUIT );
                    calRestore;
                end
            end
            if ( e > NPULSESABORT )
                promptstr = 'Timeout or no beam present.';
                if (calPromptContinue( 0, promptstr ) )
                    restore_mask = bitor( restore_mask, RESTORE_QUIT );
                    calRestore;
                end
                e = 0; % If user chooses to continue, zero err and continue scan
            end
        end
    end
    if ( tstatus ~= 1 )
        err(j) = bitor( err(j), ERR_GIRDER );
    end
    prevPlane = m; prevBpm = j; prevGirder = bpm.girder; % For use in restoring girders
end

end

function[bpm] = calScanNonGirder(a,b,cor,mon_pv,bpm_pv,nbpms,acc,rfbu07_8_predBPMs,bpm,restore_mask,bpmsel,NPOINTSCOR)
% operates on 2 BPMs, RFB07/08
calHeader;

for m = a:b
    if ( m == XPLANE )
        msg = 'Scanning X corrector';
    elseif ( m == YPLANE )
        msg = 'Scanning Y corrector';
    end
    lcaPut( msg_pv, msg );
    
    if ( lcaGet( abort_pv, 0, 'float' ) )
        restore_mask = bitor( restore_mask, RESTORE_QUIT );
        calRestore;
    end
    
    for k = 1:cor.nsteps

        lcaPut( cor.pv{m}, cor.steps(k,m) + cor.initial(m) );
        pause(2); % Wait for corrector to settle
        e = 0; % Error count for bad data
        n = 1; % Data sample count
        while n <= NSAMPLES
            newdata = 1;
            try lcaNewMonitorWait( mon_pv )
            catch ME
                disp( 'Timeout waiting for new data' );
                e = e+1;
                newdata = 0;
            end
            
            if ( newdata )
                [dataSet, e, skipPoint] = calGetData( bpm_pv, nbpms, acc, e );
                if ( ~skipPoint )
                    predData = calSelOrderXYData( dataSet, rfbu07_8_predBPMs );
                    p = NSAMPLES*(k-1) + n; % Point number
                    for j = RFB07:RFB08
                        if ( bpmsel(j) )
                            % Copy data and calculate x, x', y, y' vector at BPM
                            % bpm.dataX/Y: | urer +iuimr, ... |  bpm.bpmVecX/Y:   | x |
                            %              | vrer +ivimr, ... |                   | x'|
                            %                                                     | y |
                            %                                                     | y'|
                            %          data points -> ...
                            if ( m == XPLANE )
                                bpm(j) = storeDataX( bpm(j), p, dataSet, j );
                                bpm(j).predDataX(:,p) = predData; % X and Y data for BPMs to predict RFBU07/08 positions
                                if ( p == NPOINTSCOR ) % If all data collected
                                    bpm(j).bpmVecX  = bpm(j).r13\(bpm(j).predDataX/1000);
                                end
                            end
                            if ( m == YPLANE )
                                bpm(j) = storeDataY( bpm(j), p, dataSet, j );
                                bpm(j).predDataY(:,p) = predData; % X and Y data for BPMs to predict RFBU07/08 positions
                                if ( p == NPOINTSCOR ) % If all data collected
                                    bpm(j).bpmVecY  = bpm(j).r13\(bpm(j).predDataY/1000);
                                end
                            end
                        end
                    end
                    n = n + 1;
                end
            else
                if ( calCheckRate || (lcaGet( abort_pv, 0, 'float')) )
                    restore_mask = bitor( restore_mask, RESTORE_QUIT );
                    calRestore;
                end
            end
            if ( e > NPULSESABORT )
                promptstr = 'Timeout or no beam present.';
                if calPromptContinue( 0, promptstr )
                    restore_mask = bitor( restore_mask, RESTORE_QUIT );
                    calRestore;
                end
                e = 0; % If user chooses to continue, zero err and continue scan
            end
        end
    end
    lcaPut( cor.pv{m}, cor.initial(m) );
    pause(2); % Wait for corrector to settle
end

end


